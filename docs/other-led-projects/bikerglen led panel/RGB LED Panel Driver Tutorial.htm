<!DOCTYPE html>
<html dir="ltr" class="client-js" data-darkreader-mode="dynamic" data-darkreader-scheme="dark" lang="en"><head><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, #bit-notification-bar-iframe, embed[type="application/pdf"] {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><script class="darkreader darkreader--proxy">(function injectProxy() {
        document.dispatchEvent(new CustomEvent('__darkreader__inlineScriptsAllowed'));
        const addRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, 'addRule');
        const insertRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, 'insertRule');
        const deleteRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, 'deleteRule');
        const removeRuleDescriptor = Object.getOwnPropertyDescriptor(CSSStyleSheet.prototype, 'removeRule');
        const shouldWrapDocStyleSheets = location.hostname.endsWith('pushbullet.com') ||
            location.hostname.endsWith('ilsole24ore.com') ||
            location.hostname.endsWith('allegro.pl');
        const documentStyleSheetsDescriptor = shouldWrapDocStyleSheets ? Object.getOwnPropertyDescriptor(Document.prototype, 'styleSheets') : null;
        const cleanUp = () => {
            Object.defineProperty(CSSStyleSheet.prototype, 'addRule', addRuleDescriptor);
            Object.defineProperty(CSSStyleSheet.prototype, 'insertRule', insertRuleDescriptor);
            Object.defineProperty(CSSStyleSheet.prototype, 'deleteRule', deleteRuleDescriptor);
            Object.defineProperty(CSSStyleSheet.prototype, 'removeRule', removeRuleDescriptor);
            document.removeEventListener('__darkreader__cleanUp', cleanUp);
            document.removeEventListener('__darkreader__addUndefinedResolver', addUndefinedResolver);
            if (shouldWrapDocStyleSheets) {
                Object.defineProperty(Document.prototype, 'styleSheets', documentStyleSheetsDescriptor);
            }
        };
        const addUndefinedResolver = (e) => {
            customElements.whenDefined(e.detail.tag).then(() => {
                document.dispatchEvent(new CustomEvent('__darkreader__isDefined', { detail: { tag: e.detail.tag } }));
            });
        };
        document.addEventListener('__darkreader__cleanUp', cleanUp);
        document.addEventListener('__darkreader__addUndefinedResolver', addUndefinedResolver);
        const updateSheetEvent = new Event('__darkreader__updateSheet');
        function proxyAddRule(selector, style, index) {
            addRuleDescriptor.value.call(this, selector, style, index);
            if (this.ownerNode && !this.ownerNode.classList.contains('darkreader')) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return -1;
        }
        function proxyInsertRule(rule, index) {
            const returnValue = insertRuleDescriptor.value.call(this, rule, index);
            if (this.ownerNode && !this.ownerNode.classList.contains('darkreader')) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return returnValue;
        }
        function proxyDeleteRule(index) {
            deleteRuleDescriptor.value.call(this, index);
            if (this.ownerNode && !this.ownerNode.classList.contains('darkreader')) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyRemoveRule(index) {
            removeRuleDescriptor.value.call(this, index);
            if (this.ownerNode && !this.ownerNode.classList.contains('darkreader')) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyDocumentStyleSheets() {
            const docSheets = documentStyleSheetsDescriptor.get.call(this);
            const filtered = [...docSheets].filter((styleSheet) => {
                return !styleSheet.ownerNode.classList.contains('darkreader');
            });
            return Object.setPrototypeOf(filtered, StyleSheetList.prototype);
        }
        Object.defineProperty(CSSStyleSheet.prototype, 'addRule', Object.assign({}, addRuleDescriptor, { value: proxyAddRule }));
        Object.defineProperty(CSSStyleSheet.prototype, 'insertRule', Object.assign({}, insertRuleDescriptor, { value: proxyInsertRule }));
        Object.defineProperty(CSSStyleSheet.prototype, 'deleteRule', Object.assign({}, deleteRuleDescriptor, { value: proxyDeleteRule }));
        Object.defineProperty(CSSStyleSheet.prototype, 'removeRule', Object.assign({}, removeRuleDescriptor, { value: proxyRemoveRule }));
        if (shouldWrapDocStyleSheets) {
            Object.defineProperty(Document.prototype, 'styleSheets', Object.assign({}, documentStyleSheetsDescriptor, { get: proxyDocumentStyleSheets }));
        }
    })()</script><style class="darkreader darkreader--user-agent" media="screen">html {
    background-color: #181a1b !important;
}
html, body, input, textarea, select, button {
    background-color: #181a1b;
}
html, body, input, textarea, select, button {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #555b00 !important;
    color: #e8e6e3 !important;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}</style>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>RGB LED Panel Driver Tutorial</title>
  <meta charset="UTF-8">
	<link rel="stylesheet" href="RGB%20LED%20Panel%20Driver%20Tutorial_files/load.css"><style class="darkreader darkreader--sync" media="screen"></style>
	<style>
	  .mw-collapsible-toggle{float:right} li 
	  .mw-collapsible-toggle{float:none} 
	  .mw-collapsible-toggle-li{list-style:none}

	  .suggestions{overflow:hidden;position:absolute;top:0;left:0;width:0;border:none;z-index:1099;padding:0;margin:-1px -1px 0 0} html > body 
	  .suggestions{margin:-1px 0 0 0}
	  .suggestions-special{position:relative;background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0;margin-top:-2px;display:none;padding:0.25em 0.25em;line-height:1.25em}
	  .suggestions-results{background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0}
	  .suggestions-result{color:black;margin:0;line-height:1.5em;padding:0.01em 0.25em;text-align:left}
	  .suggestions-result-current{background-color:#4C59A6;color:white}
	  .suggestions-special 
	  .special-label{color:gray;text-align:left}
	  .suggestions-special 
	  .special-query{color:black;font-style:italic;text-align:left}
	  .suggestions-special 
	  .special-hover{background-color:silver}
	  .suggestions-result-current 
	  .special-label, .suggestions-result-current 
	  .special-query{color:white}
	  .autoellipsis-matched,.highlight{font-weight:bold}
	</style><style class="darkreader darkreader--sync" media="screen"></style>
	<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}</style><style class="darkreader darkreader--sync" media="screen"></style>
  <meta name="darkreader" content="e27040e106f477a7bb6ac49b7f0381ce"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
::placeholder {
    opacity: 0.5 !important;
}
a[href="https://coinmarketcap.com/"] > svg[width="94"][height="16"] > path {
    fill: var(--darkreader-neutral-text) !important;
}
#edge-translate-panel-body {
    color: var(--darkreader-neutral-text) !important;
}</style></head>
  <body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-RGB_LED_Panel_Driver skin-vector action-view vector-animateLayout">
	<!-- content -->
	<div id="content" class="mw-body" style="margin-left: 0px;">
	  <a id="top"></a>
	  <!-- firstHeading -->
	  <h1 id="firstHeading" class="firstHeading"><span dir="auto">RGB LED Panel Driver Tutorial</span></h1>
	  <!-- /firstHeading -->
	  <!-- bodyContent -->
	  <div id="bodyContent">
	  <!-- bodycontent -->
		<div id="mw-content-text" dir="ltr" class="mw-content-ltr" lang="en"><p><span style="color: rgb(51, 51, 51); font-family: sans-serif, arial, verdana, trebuchet ms; font-size: 13px; --darkreader-inline-color:#c8c3bc;" data-darkreader-inline-color=""></span></p>
	  <p><em><strong>Project by <a href="http://google.com/+GlenAkins">Glen Akins</a>, aka <a href="http://twitter.com/bikerglen">bikerglen</a>, aka <a href="http://www.youtube.com/ktmglen">ktmglen</a></strong></em></p>
<p>This project is © 2014 by Glen Akins. All rights reserved. It is 
released to the open source community under the terms of the GNU Public 
License (GPL) version three or higher.</p>
<p></p><table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2><span class="toctoggle">&nbsp;[<a href="#" class="internal" id="togglelink">hide</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1"><a href="#Required_Hardware"><span class="tocnumber">2</span> <span class="toctext">Required Hardware</span></a></li>
<li class="toclevel-1"><a href="#Required_Software"><span class="tocnumber">3</span> <span class="toctext">Required Software</span></a></li>
<li class="toclevel-1"><a href="#Theory_of_Operation"><span class="tocnumber">4</span> <span class="toctext">Theory of Operation</span></a>
<ul>
<li class="toclevel-2"><a href="#The_LED_Panel"><span class="tocnumber">4.1</span> <span class="toctext">The LED Panel</span></a>
<ul>
<li class="toclevel-3"><a href="#LED_Panel_Hardware"><span class="tocnumber">4.1.1</span> <span class="toctext">LED Panel Hardware</span></a></li>
<li class="toclevel-3"><a href="#Driving_the_Panel"><span class="tocnumber">4.1.2</span> <span class="toctext">Driving the Panel</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#The_FPGA"><span class="tocnumber">4.2</span> <span class="toctext">The FPGA</span></a>
<ul>
<li class="toclevel-3"><a href="#GPMC_Interface"><span class="tocnumber">4.2.1</span> <span class="toctext">GPMC Interface</span></a></li>
<li class="toclevel-3"><a href="#Register_Interface"><span class="tocnumber">4.2.2</span> <span class="toctext">Register Interface</span></a></li>
<li class="toclevel-3"><a href="#Display_Buffers"><span class="tocnumber">4.2.3</span> <span class="toctext">Display Buffers</span></a></li>
<li class="toclevel-3"><a href="#Display_Driver"><span class="tocnumber">4.2.4</span> <span class="toctext">Display Driver</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#The_Software"><span class="tocnumber">4.3</span> <span class="toctext">The Software</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Connecting_the_Hardware"><span class="tocnumber">5</span> <span class="toctext">Connecting the Hardware</span></a>
<ul>
<li class="toclevel-2"><a href="#Display_Data_Connections"><span class="tocnumber">5.1</span> <span class="toctext">Display Data Connections</span></a></li>
<li class="toclevel-2"><a href="#Display_Power_Supply_Connection"><span class="tocnumber">5.2</span> <span class="toctext">Display Power Supply Connection</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Downloading_and_Compiling_the_Software"><span class="tocnumber">6</span> <span class="toctext">Downloading and Compiling the Software</span></a></li>
<li class="toclevel-1"><a href="#Running_the_Panel_Using_the_Stock_Bit_File"><span class="tocnumber">7</span> <span class="toctext">Running the Panel Using the Stock Bit File</span></a>
<ul>
<li class="toclevel-2"><a href="#Device_Tree_Configuration"><span class="tocnumber">7.1</span> <span class="toctext">Device Tree Configuration</span></a></li>
<li class="toclevel-2"><a href="#FPGA_Configuration"><span class="tocnumber">7.2</span> <span class="toctext">FPGA Configuration</span></a></li>
<li class="toclevel-2"><a href="#Running_a_Pattern"><span class="tocnumber">7.3</span> <span class="toctext">Running a Pattern</span></a></li>
<li class="toclevel-2"><a href="#Modifying_an_Existing_Pattern"><span class="tocnumber">7.4</span> <span class="toctext">Modifying an Existing Pattern</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Rebuilding_the_Bit_File"><span class="tocnumber">8</span> <span class="toctext">Rebuilding the Bit File</span></a></li>
<li class="toclevel-1"><a href="#Simulating_the_Design"><span class="tocnumber">9</span> <span class="toctext">Simulating the Design</span></a></li>
<li class="toclevel-1"><a href="#Creating_a_New_Pattern_Subclass"><span class="tocnumber">10</span> <span class="toctext">Creating a New Pattern Subclass</span></a></li>
<li class="toclevel-1"><a href="#Ideas_for_Improvement"><span class="tocnumber">11</span> <span class="toctext">Ideas for Improvement</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">12</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#Afterword"><span class="tocnumber">13</span> <span class="toctext">Afterword</span></a></li>
</ul>
</td></tr></tbody></table>
<p></p>
<h1> <span class="mw-headline" id="Introduction">Introduction</span></h1>
<p>In this project, we interface a SparkFun or Adafruit 32x32 RGB LED 
panel to a BeagleBone Black board using the Xilinx Spartan 6 LX9 FPGA on
 the LogiBone FPGA board. The hardware for this project is relatively 
easy to construct—just 16 data signals connect the LED panel to the 
LogiBone FPGA board. The complexity of this project lies mostly in the 
RTL and software.</p>
<p>A <a href="http://youtu.be/OIyI8KaPdwk">demonstration of the project</a> is available on YouTube.</p>
<p>A <a href="http://youtu.be/LBeVMGOgWvY">demonstration of the project expanded to six panels</a> is also available on YouTube.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-introduction.jpg" style="height:506px; width:720px"></p>
<p><span style="font-size:12px"><strong>Figure 1. RGB LED panel with a random twinkling pattern connected to the LogiBone FPGA board and some other sample panel images.</strong></span></p>
<h1> <span class="mw-headline" id="Required_Hardware">Required Hardware</span></h1>
<p>The following hardware items are required:</p>
<ul>
	<li>
	<p><a href="https://www.sparkfun.com/products/12584">SparkFun</a> or <a href="http://www.adafruit.com/products/1484">Adafruit</a> 32x32 RGB LED panel<br>
	This panel contains 1024 RGB LEDs arranged in a 32x32 matrix. The 
columns are driven using multiple sets of shift registers and the rows 
are driven, two rows at a time, using a 4-bit address decoder. The panel
 is driven at 1/16<sup>th</sup> duty cycle and must be continuously refreshed to display an image.</p>
	</li>
	<li>
	<p><a href="http://beagleboard.org/Products/BeagleBone+Black">BeagleBone Black</a> CPU board w/ USB or +5VDC power supply<br>
	You’ll need a BeagleBone Black CPU board and a +5VDC power supply for 
it. You can either use a USB cable to power the board from your computer
 or a USB power adapter or use a separate +5VDC, 2.1mm I.D., 
center-positive AC adapter.</p>
	</li>
	<li>
	<p><a href="http://valentfx.com/fpga-logi-family/logi-bone">LogiBone FPGA board</a><br>
	The FPGA board contains a Xilinx Spartan 6 LX9 FPGA. The FPGA contains 
32 18kbit block RAMs. We’ll use two of the block RAMs as frame buffers 
to hold the RGB pixel values to be displayed on the panel. The two 
Digilent PMOD-compatible connectors will be used to connect to the LED 
panel.</p>
	</li>
	<li>
	<p><a href="http://www.sparkfun.com/products/9385">Jumper wires</a> or <a href="http://oshpark.com/shared_projects/AB3yQgQf">PMOD-to-display adapter board</a> to connect the FPGA to the display<br>
	Initially, I used <a href="http://www.sparkfun.com/products/9385">male-to-female jumper wires</a>
 to connect the panel. This allowed me to connect the LogiBone FPGA 
board directly to the LED display panel without using the ribbon cable 
included with the display. If you only have male-to-male jumper wires, 
you’ll need to use the 16-position ribbon cable included with the 
display as an adapter to connect to the male pins on the display end of 
the jumper wires.<br>
	A much cleaner, long-term solution is <a href="http://oshpark.com/shared_projects/AB3yQgQf">to use this board</a>
 and the 16-position ribbon cable included with the LED panel to make 
the connection from the LogiBone FPGA board to the display’s input 
connector. I also used precrimped terminal wires and housings to connect
 the FPGA and panel together. I didn’t like this solution because the 
precrimped terminal wires, when installed in a 2x8 housing connector, 
required too much force to insert onto and remove from the display’s 
data connector.</p>
	</li>
	<li>
	<p>+3.3V power supply, 2.0A nominal, 4.0A peak<br>
	During normal operation, the display will draw at most about 2A of 
current. If you “stall” the refresh with an all-white pattern displayed,
 the two rows that are lit will draw about 3.8A. A small 3.3V, 3.0A 
desktop power supply such as <a href="http://www.mouser.com/ProductDetail/Mean-Well/GS18A03-P1J/?qs=sGAEpiMZZMuBVu7Wy0UTyxARd4Un3cMx">this one from Mouser</a> will be sufficient during normal operation. You will need to supply your own <a href="http://en.wikipedia.org/wiki/IEC_60320#C13.2FC14_coupler">IEC60320 C13 power cord</a> to use with this adapter.<br>
	These panels can also be run from +5V instead of 3.3V. You will get 
brighter greens, brighter blues, and less-red whites if driven from +5V 
instead of +3.3V. You'll also pull about 15% more current and use about 
65% more power at +5V instead of +3.3V. If you use a +5V supply, be 
extra careful not to accidently connect the LogiBone FPGA board to the 
display’s output connector.</p>
	</li>
	<li>
	<p><a href="https://www.sparkfun.com/products/10288">Female DC barrel jack adapter (optional)</a><br>
	A female DC barrel jack adapter will make connecting the panel to the 
power supply much easier. If you don’t have an adapter, you can always 
cut, splice, solder, and heat shrink the connections between the power 
supply and led panel.</p>
	</li>
</ul>
<h1> <span class="mw-headline" id="Required_Software">Required Software</span></h1>
<ul>
	<li>Stock ValentFX LogiBone Ubuntu build w/ the LogiBone&nbsp;logibone_&lt;revision&gt;_dm.ko kernel module and logi_loader<br>
	Download and <a href="http://valentfx.com/wiki/index.php?title=Logi-Bone_Quick_Start_Guide#Creating_your_pre-built_LOGi_Image">follow the instructions here</a> to install the default LogiBone Ubuntu image on an SD card.</li>
	<li>Xilinx ISE WebPack Software<br>
	If you want to build the FPGA bit file yourself or customize the 
Verilog to drive more panels or add other custom functionality (such as a
 coprocessor to help compute difficult pixel patterns), you’ll need to 
download and install the Xilinx ISE WebPack software. <a href="http://valentfx.com/wiki/index.php?title=Logi-Bone_Quick_Start_Guide#Setup_Your_Development_Environment">Instructions are here</a>. If you only want to use the default FPGA bit file, you can skip installing the Xilinx ISE WebPack software.</li>
	<li>Glen’s LED panel GIT repository<br>
	Finally, you’ll need to clone my GIT repository at <a href="http://github.com/bikerglen/beagle">http://github.com/bikerglen/beagle</a>
 to your BeagleBone Black. This repository contains the Verilog source 
code for the FPGA, a prebuilt bit file, and C++ source code for 
displaying some demonstration patterns on the panel. Instructions for 
downloading or cloning and using the repository are presented later.</li>
</ul>
<h1> <span class="mw-headline" id="Theory_of_Operation">Theory of Operation</span></h1>
<p>This system has three major components: the LED panel, the FPGA code,
 and the C++ code. Let’s examine each of these three major components in
 detail.</p>
<h2> <span class="mw-headline" id="The_LED_Panel">The LED Panel</span></h2>
<h3> <span class="mw-headline" id="LED_Panel_Hardware">LED Panel Hardware</span></h3>
<p>The LED panel contains 1024 RGB LEDs arranged in a matrix of 32 rows 
and 32 columns. Each RGB LED contains separate red, green, and blue LED 
chips assembled together in a single package. The display is subdivided 
horizontally into two halves. The top half consists of 32 columns and 16
 rows. The bottom half also consists of 32 columns and 16 rows.</p>
<p>The display’s columns are driven by one set of drivers and the 
display’s rows are driven by another set of drivers. To illuminate an 
LED, the drivers for both the column and the row for that LED must be 
turned on. To change the color of an LED, the red, green, and blue chips
 in each LED package are controlled individually and have their own 
column drivers. Figure 2 below is a schematic representation of the 
display’s column and row driver organization.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-display-organization-2.png" style="height:702px; width:720px"></p>
<p><span style="font-size:12px"><strong>Figure 2. RGB LED panel</strong></span><strong> column and row driver organization.</strong></p>
<p>The panel contains six sets of column drivers; three for the top half
 of the display and three for the bottom. Each driver has 32 outputs. 
The three drivers for the top of the display drive the red, green, and 
blue chips in each of the 32 columns of LEDs in rows 0 to 15 of the 
panel. The three drivers for the bottom of the display drive the red, 
green, and blue chips in each of the 32 columns of LEDs in rows 16 to 31
 of the panel.</p>
<p>Each of the drivers has a serial data input, a blanking input, a 
shift register, and a parallel output register as shown below in Figure 
3. The data present on the serial data input is shifted into the shift 
register using the SCLK signal. After an entire row of data has been 
shifted in to the shift register, the LATCH signal is used to transfer 
the row of pixel data from the shift register into the parallel output 
register. If a bit in the output register is a ‘1’ and the blanking 
input is deasserted, the driver for that column will be enabled; 
otherwise, the driver will be turned off. Data is shifted from the right
 edge of the display to the left edge of the display. In other words, 
the first bit shifted in will be displayed on the left edge of the 
display and the last bit shifted in will be displayed on the right.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-shift-register-2.png" style="height:286px; width:720px"></p>
<p><span style="font-size:12px"><strong>Figure 3. </strong></span><strong>Column
 driver operation for the R0 data input and top-half red columns 
outputs. There are two more of these shift registers at the top of the 
display for the top-half green and blue columns and three more at the 
bottom for the bottom half red, green, and blue columns.</strong></p>
<p>The red, green, and blue column drivers for the top half of the 
display are attached respectively to the R0, G0, and B0 data inputs. The
 red, green, and blue column drivers for the bottom half of the display 
are attached respectively to the R1, G1, and B1 data inputs. All six of 
the 32-bit drivers share common SCLK, LATCH, and BLANK signals.</p>
<p>The rows are driven using four address bits and an address decoder. 
The four-bit address input to the row drivers is decoded and the two row
 drivers corresponding to that address will be turned on. When A[3:0] is
 0, rows 0 and 16 of the display are turned on. When A[3:0] is 1, rows 1
 and 17 of the display are turned on. This pattern continues until 
A[3:0] is 15 and rows 15 and 31 are turned on.</p>
<p>In addition to the row and column logic and drivers, the display has a
 blanking input. This input is most likely connected to the column 
drivers. When the blanking signal is asserted, all of the pixels are 
turned off and the display will be black. When the blanking signal is 
deasserted, the addressed rows and columns will be driven and the 
corresponding pixels illuminated. To display an image without flickering
 and ghosting, all of these signals must be used and properly sequenced 
when driving the panel.</p>
<h3> <span class="mw-headline" id="Driving_the_Panel">Driving the Panel</span></h3>
<p>The display is multiplexed and has a 1/16<sup>th</sup> duty cycle. 
This means that no more than one row out of the 16 in the top half of 
the display and one row out of the 16 in the bottom half of the display 
are ever illuminated at once. Furthermore, an LED can only be on or off.
 If both the row and column for an LED are turned on, the LED will be 
illuminated; otherwise, the LED will be off.</p>
<p>To display an image, the entire LED panel must be scanned fast enough
 so that it appears to display a continuous image without flickering. To
 display different colors and different brightness levels, the 
brightness of the red, green, and blue LED chips within each LED package
 must be adjusted by varying the amount of time that each LED chip is on
 or off within a single refresh cycle.</p>
<p>The basic process used to refresh the display when using three 
bits-per-pixel color (one bit for red; one bit for green; and one bit 
for blue) is the following:</p>
<ol>
	<li>Shift the pixel data for row 0 into the top column drivers and the 
pixel data for row 16 into the bottom column drivers using the R0, G0, 
B0, R1, G1, and B1 data inputs and the SCLK shift clock signal.</li>
	<li>Assert the blanking signal to blank the display.</li>
	<li>Set the address input to 0.</li>
	<li>Latch the contents of the column drivers‘ shift registers into the column drivers‘ output registers using the LATCH signal.</li>
	<li>Deassert the blanking signal to display rows 0 and 16.</li>
	<li>Wait some fixed amount of time.</li>
	<li>Repeat the process for each of the pairs of rows in the display.</li>
	<li>Repeat the entire process at least 100 to 200 times per second to prevent flicker.</li>
</ol>
<p>The above process uses one bit per LED color. This will give you 
eight possible colors: black; the primary colors red, green, and blue; 
the secondary colors cyan, magenta, and yellow; and white.</p>
<p><a id="BinaryCodedModulationRefresh"></a>To display more colors and brightness levels the above technique is modified to use <a href="http://www.batsocks.co.uk/readme/art_bcm_1.htm">binary coded modulation</a>.
 In binary coded modulation, each pixel is controlled using more than a 
single bit per color per pixel. The amount of time each red, green, and 
blue LED chip is on is then varied proportionally to the pixel’s red, 
green, and blue values.</p>
<p>In binary coded modulation, the following process is performed to refresh the display:</p>
<ol>
	<li>Shift bit zero of each pixel’s red, green, and blue values for rows 0 and 16 into the column drivers.</li>
	<li>Assert the blanking signal to blank the display.</li>
	<li>Set the address input to 0.</li>
	<li>Latch the contents of the column drivers‘ shift registers into the column drivers‘ output registers using the LATCH signal.</li>
	<li>Deassert the blanking signal to display rows 0 and 16.</li>
	<li>Wait some amount of time, N.</li>
	<li>Repeat the above process for the next higher order bit of color 
data in the same row. In step 6, wait two times the previous delay time.
 Repeat this process for each bit of color data, doubling the delay time
 after displaying each successive bit.</li>
	<li>Repeat the above process for each of the pairs of rows in the display.</li>
	<li>Repeat the entire process at least 100 to 200 times per second to prevent flicker.</li>
</ol>
<p>Note that in actual implementations, the process of shifting the 
pixel data into the shift registers in Step 1 is usually done during the
 wait time in Step 6.</p>
<p>Global display dimming can be performed by varying the amount of time
 the blanking signal is asserted or deasserted within the wait time 
period, N. For example, asserting the blanking signal 25% early will 
result in a display with a brightness of 75% instead of 100%. Note that 
during global dimming, the wait time itself is not shortened or 
lengthened; only the blanking signal is modified to be asserted earlier 
than it normally would be.</p>
<h2> <span class="mw-headline" id="The_FPGA">The FPGA</span></h2>
<p>The FPGA interfaces the C++ pattern generation software running on 
the BeagleBone Black CPU to the LED panel. The FPGA does the heavy 
lifting required to refresh the entire LED panel about 200 times per 
second. This leaves the BeagleBone Black CPU free to generate the 
patterns and perform other tasks.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-fpga-block-diagram.png" style="height:157px; width:720px"></p>
<p><span style="font-size:12px"><strong>Figure 4</strong></span>. Block diagram of the system including a block diagram of the FPGA’s major functional blocks.</p>
<p>As shown in Figure 4 above, software running on the BeagleBone Black 
generates patterns. These patterns are fed to the FPGA on the LogiBone 
board using the TI SOC’s GPMC bus. These patterns are written to a 
dual-port memory that serves as a display buffer. Finally a display 
controller reads the patterns out of the dual port memory, shifts the 
data into the display, and enables the row drivers as needed to display 
the image. The entire process is repeated about 200 times per second and
 generates a 32 x 32 RGB image with 12-bit color without any interaction
 from the BeagleBone Blacks’ CPU.</p>
<h3> <span class="mw-headline" id="GPMC_Interface">GPMC Interface</span></h3>
<p>The TI SOC has a programmable memory interface called the 
general-purpose memory controller (GPMC). This interface is extremely 
flexible. It can operate in both synchronous and asynchronous modes and 
the bus timing is programmable in 10ns increments. The GPMC bus will be 
used to transfer pixel data from the software on the BeagleBone Black to
 the FPGA on the LogiBone board.</p>
<p>In our system, the GPMC is configured to operate in its asynchronous,
 multiplexed address/data mode. In this mode, both the address and data 
buses are 16 bits wide. This permits an entire 12-bit pixel to be 
transferred from the CPU on the BBB to the FPGA on the LogiBone board in
 a single write operation. For more information on the GPMC’s 
asynchronous, multiplexed mode of operation, see sections 7.1.3.3.10.1.1
 of the&nbsp;<a href="http://www.ti.com/lit/pdf/spruh73">AM335x ARM® Cortex™-A8 Microprocessors Technical Reference Manual</a>.</p>
<p>I’m using a slightly different circuit in the FPGA to interface to 
the GPMC bus than the stock LogiBone projects. It’s a bit slower than 
the stock VHDL circuit, but guarantees that each write from the CPU over
 the GPMC bus creates exactly one write strobe pulse to the register 
interface inside the FPGA. Because it’s slightly slower than the stock 
circuit, it requires modified bus timing and thus a custom device tree 
setup file. Figure 5 below shows the bus timing using the modified GPMC 
interface to perform a write to the FPGA. Figure 6 below shows the bus 
timing using the modified GPMC interface to perform a read from the 
FPGA.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-gpmc-write.png" style="height:363px; width:1058px"></p>
<p><span style="font-size:12px"><strong>Figure 5. Simulation of a write to the GPMC target using the modified bus timings.</strong></span></p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-gpmc-read.png" style="height:401px; width:1060px"></p>
<p><span style="font-size:12px"><strong>Figure 6. Simulation of a read from the GPMC target using the modified bus timings.</strong></span></p>
<p>The read or write address is latched into a temporary holding 
register on the rising edge of the&nbsp; GPMC_ADVN signal and the write 
data is latached into its own temporary holding register on the falling 
edge of the GPMC_WEN signal. This requires using the GPMC_ADVN and an 
inverted version of the GPMC_WEN data signals as clocks. Technically, 
using data signals as clocks is gross. It’s actually so gross, the 
Xilinx tools will generate an error for this condition. But you can set 
an exception in the UCF file for the affected nets and force synthesis 
to continue. It would be much better to use the GPMC in its synchronous 
mode, but this technique is good enough for an FPGA until I have time to
 build a synchronous version of the interface, a synchronous GPMC bus 
model for simulation, and learn how to modify the device tree further.</p>
<p>In addition to latching the address and write data values into 
holding registers, the GPMC_CSN, GPMC_WEN, and GPMC_OEN controls signals
 are registered and brought into the FPGA’s 100MHz clock domain. Once in
 the FPGA’s clock domain, the WEN and OEN signals are gated with the CSN
 signal and edge detected to detect writes to the GPCM target and reads 
from the GPMC target. When a read or write is detected, the contents of 
the address and write data holding registers are captured into registers
 in the FPGA’s 100MHz clock domain.</p>
<p>The primary reason to slow down the GPMC bus versus the stock device 
tree setup file was to stretch the time that each of these control 
signals is low or high to at least 30ns to guarantee that the edges of 
the signals could be detected in the FPGA’s 100MHz clock domain. This 
also guaranteed that the address and data would be stable in their own 
holding registers before moving the contents of those registers into the
 address and data registers that are clocked in the FPGA’s 100MHz clock 
domain.</p>
<p>The outputs of the GPMC target are a bus that I’m calling the slow 
bus. The slow bus connects the GPMC target to the FPGA’s register 
interface. Figure 7 shows an example slow bus write operation. Figure 8 
shows an example slow bus read operation.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-sb-write.png" style="height:392px; width:940px"></p>
<p><span style="font-size:12px"><strong>Figure 7. Simulation of a slow bus write.</strong></span></p>
<p>sb_addr, sb_wr, and sb_wr_data will be valid for exactly a single 
100MHz clock pulse every time a write occurs on the GPMC bus. When the 
register interface sees sb_wr asserted, it writes sb_wr_data into the 
register at sb_addr.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-sb-read.png" style="height:393px; width:940px"></p>
<p><span style="font-size:12px"><strong>Figure 8. Simulation of a slow bus read.</strong></span></p>
<p>sb_addr and sb_rd will be valid for exactly a single 100MHz clock 
pulse every time a read occurs on the GPMC bus. The register interface 
sees sb_rd asserted then must return the value of the register at the 
address sb_addr on the sb_rd_data bus on the very next clock cycle.</p>
<h3> <span class="mw-headline" id="Register_Interface"><a id="RegisterInterface"></a>Register Interface</span></h3>
<p>The register interface is implemented in the top level of the FPGA 
Verilog. The register interface defines the view the software has of the
 FPGA. Table 1 below lists the registers in the FPGA.</p>
<table style="width:800px" cellspacing="0" cellpadding="5" border="1">
	<tbody>
		<tr>
			<td style="width:85px">
			<p style="text-align:center"><strong>FPGA Address</strong></p>
			</td>
			<td style="width:84px">
			<p style="text-align:center"><strong>BBB SOC Address</strong></p>
			</td>
			<td style="width:174px">
			<p style="text-align:center"><strong>Name</strong></p>
			</td>
			<td style="width:295px">
			<p style="text-align:center"><strong>Description</strong></p>
			</td>
		</tr>
		<tr>
			<td style="vertical-align:top; width:85px">
			<p>0x0000</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>0x0000</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>R/W Test Reg 1</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Read / write test register. Write any value to this register. Reads return previously written value.</p>
			</td>
		</tr>
		<tr>
			<td style="vertical-align:top; width:85px">
			<p>0x0001</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>0x0002</p>
			</td>
			<td style="border-color: rgb(0, 0, 0); vertical-align: top; width: 85px; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="">
			<p>R/W Test Reg 2</p>
			</td>
			<td style="border-color: rgb(0, 0, 0); vertical-align: top; width: 85px; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="">
			<p>Read / write test register. Write any value to this register. Reads return previously written value.</p>
			</td>
		</tr>
		<tr>
			<td style="vertical-align:top; width:85px">
			<p>0x0002</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>0x0004</p>
			</td>
			<td style="border-color: rgb(0, 0, 0); vertical-align: top; width: 85px; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="">
			<p>R/W Test Reg 3</p>
			</td>
			<td style="border-color: rgb(0, 0, 0); vertical-align: top; width: 85px; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="">
			<p>Read / write test register. Write any value to this register. Reads return previously written value.</p>
			</td>
		</tr>
		<tr>
			<td style="vertical-align:top; width:85px">
			<p>0x0003</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>0x0006</p>
			</td>
			<td style="border-color: rgb(0, 0, 0); vertical-align: top; width: 85px; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="">
			<p>R/W Test Reg 4</p>
			</td>
			<td style="border-color: rgb(0, 0, 0); vertical-align: top; width: 85px; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="">
			<p>Read / write test register. Write any value to this register. Reads return previously written value.</p>
			</td>
		</tr>
		<tr>
			<td style="vertical-align:top; width:85px">
			<p>0x0004</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>0x0008</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Read-Only Test Reg 1</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Read-only test registers. Reads return hard-coded values. See RTL for returned values.</p>
			</td>
		</tr>
		<tr>
			<td style="vertical-align:top; width:85px">
			<p>0x0005</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>0x000a</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Read-Only Test Reg 2</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Read-only test registers. Reads return hard-coded values. See RTL for returned values.</p>
			</td>
		</tr>
		<tr>
			<td style="vertical-align:top; width:85px">
			<p>0x0006</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>0x000c</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Read-Only Test Reg 3</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Read-only test registers. Reads return hard-coded values. See RTL for returned values.</p>
			</td>
		</tr>
		<tr>
			<td style="vertical-align:top; width:85px">
			<p>0x0007</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>0x000e</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Read-Only Test Reg 4</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Read-only test registers. Reads return hard-coded values. See RTL for returned values.</p>
			</td>
		</tr>
		<tr>
			<td style="vertical-align:top; width:85px">
			<p>0x0008</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>0x0010</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Display Buffer Address Register</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Writes to this register set the display buffer address pointer. 
The display buffer address pointer points to the location in the display
 buffer memory that will be modified when a pixel value is written to 
the display buffer data register. See the display buffer section of this
 document for the arrangement of pixels in memory.</p>
			</td>
		</tr>
		<tr>
			<td style="vertical-align:top; width:85px">
			<p>0x0009</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>0x0012</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Display Buffer Data Register</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Writing a pixel value to this register writes the pixel value to 
the display buffer at the address pointed to by the display buffer 
address pointer. After each write, the display buffer address pointer is
 incremented by one to point at the next pixel in the display buffer.</p>
			</td>
		</tr>
		<tr>
			<td style="vertical-align:top; width:85px">
			<p>0x000a</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>0x0014</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>Display Buffer Select Register</p>
			</td>
			<td style="vertical-align:top; width:85px">
			<p>0 selects buffer 0 for display; 1 selects buffer 1 for display; Reads return which buffer is currently being displayed.</p>
			</td>
		</tr>
	</tbody>
</table>
<p><span style="font-size:12px"><strong>Table 1. FPGA registers.</strong></span></p>
<h3> <span class="mw-headline" id="Display_Buffers">Display Buffers</span></h3>
<p>The display buffers are implemented usinx Xilinx Block RAMs 
configured as dual-port memories with asynchronous read and write ports.
 The first RAM contains display buffers 0 and 1 for the top half of the 
display. The second RAM contains display buffers 0 and 1 for the bottom 
half of the display. Structuring the memories to contain half the 
display each permits the pixels in rows 0 to 15 to be read from memory 
on the exact same clock that the pixels in rows 16 to 31 are read from 
memory.</p>
<p>Display buffer 0 is located at address 0x0000. Display buffer 1 is 
located at address 0x0400. Each display buffer contains 1024 12-bit RGB 
values arranged as 32 rows of 32 columns. Within each display buffer, 
the top-left pixel is stored at offset 0, the bottom-right pixel is 
stored at offset 0x3ff. Bits 4 to 0 of the pixel offset are 0x00 for 
pixels in the leftmost column on the display; bits 4 to 0 of the pixel 
offset are 0x1F for pixels in the rightmost column.</p>
<p>Pixels are stored in the memory as 12-bit RGB values. These values 
are stored right-justiified. Bits 11 to 8 are the red pixel level, bits 7
 to 4 are the green level, and bits 3 to 0 are the blue level.</p>
<h3> <span class="mw-headline" id="Display_Driver">Display Driver</span></h3>
<p>The display driver reads pixel values from memory, shifts those 
values to the display, and cycles through the rows of the display as 
required to implement binary coded modulation as described in the <a>theory of operation section</a>
 of this document. The display driver is implemented as a state machine.
 Each state implements a step in the refresh process. When that step is 
complete, the state machine moves to the next step in the process.</p>
<p>Figure 9 below shows simulation waveforms for the control and data 
outputs for three rows worth of display data. The basic process is to 
blank the display, latch in the previously shifted data, update the row 
selects, unblank the display, shift in the next set of pixel data, and 
then wait for an update timer to expire. This is repeated four times for
 each row. If you examine the blanking output, you’ll notice that its 
low period doubles three times within the output period for each display
 row. This is the result of using binary coded modulation to vary the 
intensity of each pixel.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-display-data-outputs.png" style="height:515px; width:1436px"></p>
<p><span style="font-size:12px"><strong>Figure 9. Simulation waveforms for the display data output connections.</strong></span></p>
<h2> <span class="mw-headline" id="The_Software">The Software</span></h2>
<p>The demonstration software uses the /dev/logibone_mem device to 
communicate with the FPGA. The driver for this device is part of the 
stock LogiBone Ubuntu image and its loadable kernel module is installed 
by the modified device tree setup shell script that’s included in the 
GitHub repository for the LED panel. (More on this subject in a later 
section.) This driver maps the registers in the FPGA to a portion of the
 BBB CPU’s address space using the GPMC. The GPMC normally maps memory 
into the CPU’s address space. Because our FPGA looks like a memory to 
the GPMC bus, its registers can be mapped into the CPU address space 
too. Pretty cool. No SPI, I2C, etc.; just fast parallel accesses between
 the CPU and the FPGA. This memory-mapped space can then be accessed by 
opening the /dev/logbone_mem device using the C library <em>open</em> function call and reads and writes to a register in the FPGA can be performed using the <em>pread</em> and <em>pwrite</em> C library function calls.</p>
<p>Figure 10 below is a block diagram of the demonstration software stack. In the demonstration software, <em>main</em> opens the /dev/logibone_mem device, fills the global buffer memory, <em>gLevels</em>, with all black, and then calls <em>WriteLevels</em>
 to write the global buffer to the display and clear the display. Once 
the display is cleared, the main function instantiates a pattern / 
animation subclass such as a radiating circle, perlin noise, or 
colorwash subclass. This subclass is derived from a generic pattern base
 class.</p>
<p>The generic pattern base class uses a constructor to set the height 
and width of the pattern to generate. Derived classes may add their own 
arguments to their own constructors. The base class also has two pure 
virtual member functions, <em>init</em> and <em>next</em>, that any derived classes must implement. The <em>init</em>
 function prepares a pattern to be displayed for the first time. It 
typically resets any state information back to the start of the pattern.
 The <em>next</em> function calculates the next frame of the pattern and writes that frame to the global <em>gLevels</em> buffer.</p>
<p>After <em>main</em> has instantiated the pattern subclass, it calls the subclass’s <em>init</em> funciton. <em>Main</em>
 then installs a timer that executes at 50Hz and goes to sleep. When the
 timer expires, a timer handler function is called. The timer handler 
function calls <em>WriteLevels</em> to write the previously computed frame in <em>gLevels </em>to
 the next available display buffer in the FPGA and makes that display 
buffer active. The writes to the FPGA display buffers are performed 
using the registers documented in the <a>Register Interface</a> section of this document.</p>
<p>After <em>WriteLevels</em> has completed, the timer handler function calls the pattern’s <em>next</em> member function. The <em>next</em> function generates the next frame in the animation, writes that frame to <em>gLevels</em>, and returns<em>—without calling WriteLevels.</em> The timer handler then sleeps until the next time the timer expires. By calling <em>WriteLevels</em> before calling <em>next</em>, the amount of time between displayed frames will not vary even if the amount of time that<em> next</em> takes to execute varies between frames.</p>
<p>In order for animations to run smoothly, the timer handler function 
must complete execution before the timer expires next. This means that 
each frame in the animation must take less than roughly 20ms to compute.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-software-block1.png" style="height:389px; width:576px"></p>
<p><span style="font-size:12px"><strong>Figure 10. Block diagram of the demonstration software stack.</strong></span></p>
<h1> <span class="mw-headline" id="Connecting_the_Hardware">Connecting the Hardware</span></h1>
<p>The display requires only a data connection to the LogiBone FPGA 
board and a power connection to a +3.3V power supply to operate. These 
connections are detailed in the sections below.</p>
<h2> <span class="mw-headline" id="Display_Data_Connections">Display Data Connections</span></h2>
<p>Figure 11 below lists the connections between the PMOD connectors and
 the display’s data input connector. You will need to make 16 
connections total between the LogiBone board and the display panel. 
Thirteen of these are data connections; three of these are grounds. You 
can either use jumper wires or the PMOD-to-display adapter board. If you
 use jumper wires, the wiring will look something like Figure 12. With 
the adapter board, it will look something like Figure 13. Note that the 
PMOD connectors’ pins are numbered differently than double row headers 
are normally numbered.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-display-data-connections.png" style="height:518px; width:720px"></p>
<p><span style="font-size:12px"><strong>Figure 11. PMOD connector pin 
outs, connections between the PMOD connectors and the display input 
connector, and the display connector pin out.</strong></span></p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-with-power.png" style="height:405px; width:720px"></p>
<p><span style="font-size:12px"><strong>Figure 12. </strong></span><strong>LogiBone FPGA board connected to RGB LED panel using jumper wires.</strong></p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-data-with-board.jpg" style="height:480px; width:720px"></p>
<p><span style="font-size:12px"><strong>Figure 13. </strong></span><strong>LogiBone FPGA board connected to RGB LED panel using the PMOD-to-display adapter board.</strong></p>
<h2> <span class="mw-headline" id="Display_Power_Supply_Connection">Display Power Supply Connection</span></h2>
<p>Once the data signals have been connected, make the power supply 
connection to the display. Figure 14 below shows the basics. Using the 
DC barrel jack adapter, connect the positive terminal of the power 
supply to the red wire of the wire harness and connect the negative 
terminal of the power supply to the black wire of the wire harness. 
Before connecting the wire harness to the display, use a volt meter to 
verify the polarity of the connections. Once you’ve verified the 
polarity, disconnect the power and plug the wire harness into the 
display.</p>
<p>I left the spade lugs on the wire harness because I plan on using the
 display in a bigger project and don’t want to remove them until I’m 
sure I don’t need them in the bigger project. If you leave the spade 
lugs on too, be careful they don’t accidentally short to any other 
electronics. You might want to wrap them with electrical tape just to be
 sure. If you don’t need or want the spade connectors, feel free to cut 
them off, strip a bit of insulation off the wires, and connect them 
directly to the DC barrel jack adapter.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-power-1.jpg" style="height:479px; width:720px"></p>
<p><span style="font-size:12px"><strong>Figure 14. </strong></span><strong>Connecting the power supply to the RGB LED panel using a female DC barrel jack adapter.</strong></p>
<h1> <span class="mw-headline" id="Downloading_and_Compiling_the_Software">Downloading and Compiling the Software</span></h1>
<p>The stock LogiBone Ubuntu image includes both the git revision 
control software and the GCC C/C++ compiler suite. We'll use git to 
clone the code repository to the BeagleBone Black then we’ll use g++, 
the GCC C++ compiler, to compile the C software to drive the panel.</p>
<p>Change to your home directory using the cd command and execute the git clone command to retrieve the repository:</p>
<div style="background: rgb(238, 238, 238) none repeat scroll 0% 0%; border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgcolor:#222426; --darkreader-inline-bgimage:none; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""><code>ubuntu@arm:$ cd<br>
<p>ubuntu@arm:$ git clone <a rel="nofollow" class="external free" href="http://github.com/bikerglen/beagle">http://github.com/bikerglen/beagle</a> led-panel<br>
Cloning into 'led-panel'...<br>
remote: Reusing existing pack: 226, done.<br>
remote: Total 226 (delta 0), reused 0 (delta 0)<br>
Receiving objects: 100% (226/226), 61.51 KiB | 110 KiB/s, done.<br>
Resolving deltas: 100% (84/84), done.<br>
</p>
ubuntu@arm:$ </code></div>
<p>The 'cd' command without any arguments changes to your home 
directory. The git clone command copies the repository from the 
specified URL to the 'led-panel' directory. If you want to use a 
different name for the directory, feel free but you'll need to change 
the path the in the rest of the commands that follow too.</p>
<p>Now change directories to the 'software' directory and execute the 'make' command to build the code:</p>
<div style="background: rgb(238, 238, 238) none repeat scroll 0% 0%; border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgcolor:#222426; --darkreader-inline-bgimage:none; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="">ubuntu@arm:$ cd led-panel/projects/led-panel-v01/software/<br>
<p>ubuntu@arm:$ make<br>
g++ -c runcircle.cpp<br>
g++ -c pattern.cpp<br>
g++ -c circle.cpp<br>
g++ -o runcircle runcircle.o pattern.o circle.o<br>
g++ -c runperlin.cpp<br>
g++ -c perlin.cpp<br>
g++ -o runperlin runperlin.o pattern.o perlin.o<br>
g++ -c runwash.cpp<br>
g++ -c wash.cpp<br>
g++ -o runwash runwash.o pattern.o wash.o<br>
g++ -c runtwinkle.cpp<br>
g++ -c twinkle.cpp<br>
g++ -o runtwinkle runtwinkle.o pattern.o twinkle.o<br>
g++ -c runwipe.cpp<br>
g++ -c wipe.cpp<br>
g++ -o runwipe runwipe.o pattern.o wipe.o<br>
g++ -o blank blank.cpp<br>
g++ -o picture picture.cpp<br>
</p>
ubuntu@arm:$</div>
<p>Congratulations! All the code is now compiled. This builds the 
runcircle, runperlin, runwash, runtwinkle, runwipe, blank, and picture 
commands. Each of the 'run' commands produces a different animated 
pattern on the display. The blank command clears the display. The 
picture command displays an image on the panel. The filename of the 
image is supplied as the first argument to the command. The image must 
be a 32x32 24-bit color image in interleaved RGB format.</p>
<h1> <span class="mw-headline" id="Running_the_Panel_Using_the_Stock_Bit_File">Running the Panel Using the Stock Bit File</span></h1>
<p>Now let’s run the panel. We have two preparation steps to perform 
then we can run our first animated pattern on the display. The first 
preparation step is to configure the BeagleBone Black hardware to use 
the LogiBone FPGA board. Once that’s done, we need to load the FPGA’s 
configuration file into the FPGA.</p>
<h2> <span class="mw-headline" id="Device_Tree_Configuration">Device Tree Configuration</span></h2>
<p>The BeagleBone Black Ubuntu distribution uses kernel device trees to 
configure the CPU to use any attached capes or other hardware. The 
device tree maps hardware functions to pins, sets the data direction 
registers for pins, and configures any other registers in the CPU needed
 to use the attached hardware. Once the device tree for the added 
hardware has been loaded, the linux kernel loadable modules for the 
attached hardware’s device drivers can be loaded into the kernel. The 
stock LogiBone Ubuntu image includes a shell script to configure the 
device tree for the LogiBone FPGA board and load the LogiBone board’s 
hardware driver kernel modules.</p>
<p>Another function of the device tree is to configure the timing of the
 GPMC bus. SInce we modified the timing of the GPMC bus in our RTL, we 
need to make a few changes to the default device tree configuration file
 for the LogiBone FPGA board so that the CPU implements the same 
modified timng. The device tree file containing this modified timing is 
called “BB-BONE-LOGIBONE-SLOW.dts’ and is in the repository we cloned to
 our BBB early. There’s also a shell script called 
‘setup_device-tree-slow.sh’ that compiles the .dts file into a .dtbo 
file, loads the modified device tree configuration file, and loads the 
LogiBone FPGA board’s device driver. We need to copy both the dts file 
and the shell script to our home directory:</p>
<div style="background: rgb(238, 238, 238) none repeat scroll 0% 0%; border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgcolor:#222426; --darkreader-inline-bgimage:none; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""><code>ubuntu@arm:$ cd<br>
<p>ubuntu@arm:$ cp led-panel/projects/led-panel-v01/config-scripts/setup_device-tree-slow.sh .<br>
ubuntu@arm:$ cp led-panel/projects/led-panel-v01/config-scripts/BB-BONE-LOGIBONE-SLOW.dts .<br>
</p>
ubuntu@arm:$ </code></div>
<p>Now that the shell script and device tree configuration file have been copied to the home directory, let’s run them:</p>
<div style="background: rgb(238, 238, 238) none repeat scroll 0% 0%; border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgcolor:#222426; --darkreader-inline-bgimage:none; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""><code>ubuntu@arm:$ cd<br>
<p>ubuntu@arm:$ sudo ./setup_device-tree-slow.sh<br>
rm: cannot remove `/lib/firmware/BB-BONE-LOGIBONE-SLOW.dtbo': No such file or directory<br>
&nbsp;0: 54:PF---<br>
&nbsp;1: 55:PF---<br>
&nbsp;2: 56:PF---<br>
&nbsp;3: 57:PF---<br>
&nbsp;7: ff:P-O-L Override Board Name,SLOW,Override Manuf,BB-BONE-LOGIBONE<br>
</p>
ubuntu@arm:$</code></div>
<p>The first time the shell script is executed, the .dtbo file does not 
exist so you’ll get an error message that you can safely ignore. Also 
note that you may be prompted to enter your user password in order to 
authenticate yourself to the sudo command and run the setup shell script
 as root.</p>
<p>The device tree is now configured and the LogiBone board’s kernel 
level device driver has been loaded! Time to configure the FPGA.</p>
<h2> <span class="mw-headline" id="FPGA_Configuration">FPGA Configuration</span></h2>
<p>The next step is to load the configuration bit file into the FPGA. 
The configuration bit file is generated by the Xilinx ISE tools and 
contains our complete synthesized and routed design. Without the 
configuration file, the FPGA is nothing but a bunch of disconnected 
gates, memories, lookup tables, and routing resources. The configuration
 file connects the various resources together in the FPGA in such a way 
as to implement the logic we specified in our source code. The process 
of turning the source code into elements that exist in the FPGA is 
called <em>synthesis</em>. Xilinx divides the synthesis process into two stages: <em>translation</em>, where the code is compiled into primitive gates, and <em>mapping</em>,
 where the gates are arranged into CLBs and LUTs. The process of 
determining exactly which elements in the FPGA are used and how they’re 
connected using the available gates and routing resources is called <em>place and route</em>. After synthesis and place and route, a third process called <em>static timing analysis</em> runs to ensure that the design operates at the requested speed.</p>
<p>The LogiBone board’s stock Ubuntu image includes a utility called 
logi_loader in /usr/local/bin. The logi_loader utility loads a bit file 
specifed on the command line into the FPGA.&nbsp; The repository cloned 
onto the BBB earlier contains a pre-built configuration bit file so we 
can get started quickly with the FPGA and the display. Let’s give our 
FPGA some intelligence by loading the pre-built bit file into it using 
the logi_loader command:</p>
<div style="background: rgb(238, 238, 238) none repeat scroll 0% 0%; border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgcolor:#222426; --darkreader-inline-bgimage:none; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""><code>ubuntu@arm:$ cd<br>
<p>ubuntu@arm:$ sudo logi_loader led-panel/projects/led-panel-v01/fpga/bitfiles/beagle01.bit<br>
0+1 records in<br>
0+1 records out<br>
340714 bytes (341 kB) copied, 0.963579 s, 354 kB/s<br>
</p>
ubuntu@arm:$</code></div>
<p>If all is well, the two user LEDs on the LogiBone FPGA should be 
blinking at slightly different rates. At this point you can connect 
power to the display. The display should be blank. (During the FPGA 
design phase, I set the defaults contents of the memories in the design 
to be all zero. A welcome message would have been cool too.)</p>
<h2> <span class="mw-headline" id="Running_a_Pattern">Running a Pattern</span></h2>
<p>Now let’s run one of the patterns we compiled earlier on the display.
 The Perlin noise pattern is pretty cool. Change to the software 
directory and run the runperlin executable as root:</p>
<div style="background: rgb(238, 238, 238) none repeat scroll 0% 0%; border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgcolor:#222426; --darkreader-inline-bgimage:none; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""><code>ubuntu@arm:$ cd<br>
<p>ubuntu@arm:$ cd led-panel/projects/led-panel-v01/software/<br>
ubuntu@arm:$ sudo ./runperlin<br>
</p>
^Cubuntu@arm:$</code></div>
<p>Hopefully, the display is showing a mesmerizing and constantly 
changing pseudorandom pattern now! If not, make sure you included sudo 
in front of ./runperlin to run the command as root. The 
/dev/logibone_mem devce is only accessible by root. If the colors seem 
odd, check that the signals to the column drivers are connected 
correctly. If rows are swapped, check the signals to the row drivers. If
 the display looks like the top and bottom are swapped, check that 
R0,G0,B0 are not swapped with R1,G1,B1. If that fails, use a logic 
analyzer or scope to examine the signals between the display and the 
FPGA and ensure they look like their counter parts in the simulation of 
the FPGA.</p>
<p>Once you have everything working and have had enough of the Perlin 
noise, type ctrl-c to exit the runperlin program. Experiment with 
running some of the other patterns. The runwash and runcircle animations
 are pretty cool. There are also a biker and a beagle raw image files 
for use with the picture command in the repository. If you have the 
display sitting between you and your monitor and it’s starting to burn 
your eyes, use the blank command to clear the display back to all black.</p>
<h2> <span class="mw-headline" id="Modifying_an_Existing_Pattern">Modifying an Existing Pattern</span></h2>
<p>Let’s make a quick change to the Perlin noise display, compile the 
change, and re-run the runperlin command. The Perlin noise algorithm has
 an x/y scale parameter that controls the rough size of the displayed 
blobs. Let’s change this from 8 / 64 to 4 / 64 and observe the effects 
on the displayed images.</p>
<p>The Perlin subclass is declared in perlin.h. Open perlin.h using an 
editor (like vi) on the BBB and look for the longer of the two 
C++constructors:</p>
<div style="background: rgb(238, 238, 238) none repeat scroll 0% 0%; border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgcolor:#222426; --darkreader-inline-bgimage:none; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // constructor<br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // m_hue_option is hue offset from 0.0 to 1.0 for mode 1, hue step for modes 2 and 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Perlin (const int32_t width, const int32_t height,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int32_t mode, const float xy_scale,<br>
</p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 float z_step, const float z_depth, const float hue_options);</code></div>
<p>As you can see above, the fourth argument to the constructor is 
xy_scale and it is of type float. That is the parameter we want to 
change.</p>
<p>runperlin.cpp declares gPattern of type Perlin and then instantiates 
an instance of that class using the new operator. Find the “gPattern = 
new Perlin (…);” in runperlin.cpp:</p>
<div style="background: rgb(238, 238, 238) none repeat scroll 0% 0%; border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgcolor:#222426; --darkreader-inline-bgimage:none; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""><code>&nbsp;&nbsp;&nbsp; // create a new pattern object -- perlin noise, mode 2 long repeating<br>
&nbsp;&nbsp;&nbsp; gPattern = new Perlin (DISPLAY_WIDTH, DISPLAY_HEIGHT, 2, 8.0/64.0, 0.0125, 512.0, 0.005);</code></div>
<p>The fourth argument to the constructor is 8.0/64.0. Let’s change that to 4.0/64.0:</p>
<div style="background: rgb(238, 238, 238) none repeat scroll 0% 0%; border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgcolor:#222426; --darkreader-inline-bgimage:none; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""><code>&nbsp;&nbsp;&nbsp; // create a new pattern object -- perlin noise, mode 2 long repeating<br>
&nbsp;&nbsp;&nbsp; gPattern = new Perlin (DISPLAY_WIDTH, DISPLAY_HEIGHT, 2, 4.0/64.0, 0.0125, 512.0, 0.005);</code></div>
<p>Save the file and exit the editor. Now recompile everything and run the runperlin command again as root:</p>
<div style="background: rgb(238, 238, 238) none repeat scroll 0% 0%; border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgcolor:#222426; --darkreader-inline-bgimage:none; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""><code>ubuntu@arm:$ make<br>
<p>g++ -c runperlin.cpp<br>
g++ -o runperlin runperlin.o pattern.o perlin.o<br>
ubuntu@arm:$&nbsp;sudo ./runperlin<br>
</p>
ubuntu@arm:$</code></div>
<p>Notice the different size of the blobs compared to the first time you executed the runperlin command?</p>
<p>Extra credit: Make the runperlin script listen for UDP packets 
containing new xy_scale and z_step parameters and change those 
parameters using the setter functions of the Perlin class as new UDP 
packets arrive. Use an Arduino, an Ethernet shield, and two 
potentiometers to generate the UDP packets.</p>
<h1> <span class="mw-headline" id="Rebuilding_the_Bit_File">Rebuilding the Bit File</span></h1>
<p>If you would like to edit the led panel Verilog to include your own 
modifications, you’ll eventually need to rebuild the FPGA and create a 
new configuration bit file. Let’s walk through the process of rebuilding
 the FPGA from the original source code. You can then modify the source 
code to include your own changes and run it through the process in a 
similar manner. Note that rebuilding the FPGA and configuraiton bit file
 requires that the <a href="http://valentfx.com/wiki/index.php?title=Logi-Bone_Quick_Start_Guide#Setup_Your_Development_Environment">Xilinx ISE WebPack</a> tools are installed.</p>
<p>The first step is to copy the 
~/led-panel/beagle/projects/led-panel-v01/fpga directory from the 
BeagleBone Black to the machine where the Xilinx ISE tools are 
installed. This directory contains the Verilog source code for driving 
the LED panel, the Xiliinx ISE project files, and the Xilinx IP core 
generator files for the PLL and memories. You can perform the copy in 
one of several ways. You can clone the repostiory from GitHub down to 
your build machine, use scp to copy the directory from the BeagleBone 
Black to the build machine, or use an FTP client such as <a href="https://filezilla-project.org/">Filezilla</a>
 (using port 22 for SFTP) to copy the directories from the BeagleBone 
Black to the build machine. The first two solutions work well if your 
build machine is running Linux. I'd suggest using Filezilla if your 
build machine is running Windows.</p>
<p>Once the directory is copied, launch the Xiinx ISE Project Navigator 
from the Windows start menu as shown below in Figure 15. On Linux, 
ensure the path to the tools is in your path environment variable and 
execute <em>ise</em> from the command line.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/01-launch-ise.jpg" style="height:378px; width:431px"></p>
<p><span style="font-size:12px"><strong>Figure 15. Launching the Xilinx ISE Project Navigator</strong></span></p>
<p>Once the tool has launched, close any projects that opened when the 
the tool launched using the File menu then the Close Project option. Now
 click the “Open Project…” button as shown below in Figure 16.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/02-open-project.jpg" style="height:376px; width:573px"></p>
<p><span style="font-size:12px"><strong>Figure 16. Open project button when no other projects are opened.</strong></span></p>
<p>The ISE GUI will display a standard file chooser dialog bog as shown 
below in Figure 17. Navigate to the build directory inside the fpga 
directory you copied to the build machine earlier. Select the 
beagle01.xise project file from this directory and click open.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/03-project-path.jpg" style="height:436px; width:667px"></p>
<p><span style="font-size:12px"><strong>Figure 17. Opening the beagle01.xise project file.</strong></span></p>
<p>The tool will open the beagle01 project and do some initial 
processing on the design. If the tool cannot find any files in the 
design, it will alert you to the missing files and give you the 
opportunity to locate those files now. Once everything has opened 
successfully, the screen will look similar to that in Figure 18. To 
rebuild the design from the original Verilog, click <em>Implementation</em> and click <em>beagle01</em> in the hierarchy pane. Finally right click <em>Generate Programming File</em> and select <em>Rerun All</em>. These sections of the screen are highlighted in red in Figure 18 below.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/04-rerun-all.jpg" style="height:826px; width:1153px"></p>
<p><span style="font-size:12px"><strong>Figure 18. </strong></span><strong>Project successfully opened with items required to rebuild entire design highlighted.</strong></p>
<p>Once you click <em>Rerun All</em>, the tool will re-run the entire 
flow, starting from the source code, through synthesis, translation, 
mapping, place and route, and static timing analysis. If all of these 
processes run successfully, the tool will generate a programming file 
called <em>beagle01.bit </em>in the <em>build</em> directory. After generating the programming file successfully, the screen will look something like Figure 19.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/05-generated-ok.jpg" style="height:826px; width:1158px"></p>
<p><span style="font-size:12px"><strong>Figure 19. </strong></span><strong>Successful synthesis, mapping, translation, place and route, and programming file generation.</strong></p>
<p>Once the bit file has been generated, the bit file can be copied back
 to the BeagleBone Black using scp or an FTP client such as Filezilla 
(again use port 22 for SFTP). Once on the BeagleBone Black, the design 
can be loaded into the FPGA and tested using the <em>logi_loader</em> command.</p>
<h1> <span class="mw-headline" id="Simulating_the_Design">Simulating the Design</span></h1>
<p>With an FPGA, the tempation is there to develop your RTL just like 
you do any old piece of code: write, compile, debug, and iterate. That 
does not work for FPGA development. First, synthesis and place and 
route, especially on larger designs, can take much longer than compiling
 C or C++ code. Second, it’s really hard to observe signals inside an 
FPGA running in a real system.</p>
<p>Simulation solves both of these problems. Simulation speeds the time 
between write, compile, and debug iterations by replacing the lengthy 
synthesis / routing processes with what can be a much briefer compile, 
elaborate, and run process. Simulation also lets you observe every 
signal of interest in the FPGA at once. I cannot emphasize it enough. 
The key to creating a working FPGA is having a working simulation. The 
keys to having a working simulation are to accurately model the hardware
 attached to the FPGA and to target the simulation to the specific 
behaviors you want to observe in the FPGA. And a lot of time, the 
behaviors you want to observe are not only the normal operational 
behavior of the system but also the behavior of the system in response 
to error conditions.</p>
<p>Simulations require a testbench. The testbench contains 
instantiations of any device models (models of any hardware outside the 
FPGA), an instantiation of the device under test (the RTL for the FPGA),
 and test stimulus (for example, a test script used to run a series of 
steps in a test plan against the FPGA RTL). Additionally, the testbench 
may contain clock generators to generate the clocks used by the system 
and scripts to automate checking the results of the simulation.</p>
<p>Our testbench module is called testbench and is in the file 
testbench.v inside the fpga/test directory. In our testbench, we have a 
model of the GPMC host running inside the CPU on the BeagleBone Black, 
an instance of the beagle01 top-level module for our FPGA, a clock 
generator, a test script that writes data into the FPGA using the GPMC 
bus, and some code to monitor the column outputs from the FPGA,</p>
<p>Let’s run a quick simulation of the LED panel FPGA using the isim 
simulator built into the Xilinx ISE WebPack software and our testbench. 
Launch the Xilinx ISE Project Navigator and open the beagle01.xise 
project. Once the project is open, click <em>Simulation</em> and click on <em>testbench (testbench.v) </em>in the <em>Hierarchy</em> panel. Expand the <em>ISim Simulator</em> process, right click on <em>Simulate Behavioral Model</em> and select <em>Rerun All</em>. These sections of the screen are highlighted in red in Figure 20 below.&nbsp;</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/10-launch-sim.jpg" style="height:826px; width:1157px"></p>
<p><span style="font-size:12px"><strong>Figure 20. Launching ISim.</strong></span></p>
<p>Once <em>Rerun All </em>is selected, the ISim simulator will launch. 
The source code for the testbench, the models, the FPGA, and any Xilinx 
IP core generator modules will&nbsp; be compiled and elaborated. Once 
elaborated, the simulation will begin running. Our testbench uses the <em>$finish</em>
 system task to stop the simulator once the test has completed. Once the
 simulation has run to completion, the screen will look like that in 
Figure 21 showing the line of code containing the <em>$finish</em> 
system task that caused the simulation to stop. Click the little X 
highlighted by the red box in the Figure 21 to close the testbench.v 
file.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/11-sim-stopped.jpg" style="height:809px; width:1352px"></p>
<p><span style="font-size:12px"><strong>Figure 21. Simulation complete. Close the&nbsp; text editor to view the waveforms.</strong></span></p>
<p>Once the testbench source code window is closed, the screen will show
 some waveforms for the simulation as shown below in Figure 22.</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/12-sim-waves.jpg" style="height:807px; width:1349px"></p>
<p><span style="font-size:12px"><strong>Figure 22. Simulation waveforms.</strong></span></p>
<p>At this point you can use the mouse and menu items to zoom into and 
out of the waveforms. You can also dig into the hierachy of the 
testbench and the design using the left pane and add signals to the 
waveform display by dragging signals from the middle pane to the 
waveform display on the right side of the window. To update the 
waveforms to contain values for the newly added signals, re-run the 
simulation using the <em>Rerun</em> item under the <em>Simulation </em>menu. If you modified the test bench or the FPGA source code, you’ll need to relaunch the simulator using the <em>Relaunch</em> item under the <em>Simulation</em> menu. <em>Relaunch</em>
 will recompile and re-elaborate the testbench, modules, and cores in 
the design. Be sure to save the wcfg file if you want to have the same 
signals displayed in the waveforms pane after the simulator has 
relaunched.</p>
<h1> <span class="mw-headline" id="Creating_a_New_Pattern_Subclass">Creating a New Pattern Subclass</span></h1>
<p>To create a new class to display a new pattern on the panel, derive a subclass from the parent <em>Pattern </em>class. Listings 1 and 2 below show the minimum contents of the header and C++ source files for a new pattern subclass called <em>MyPattern</em>.</p>
<div style="background: rgb(238, 238, 238) none repeat scroll 0% 0%; border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgcolor:#222426; --darkreader-inline-bgimage:none; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""><code>#ifndef __mypattern_h_<br>
</code><p><code>#define __mypattern_h_</code><br>
<br>
<code>class MyPattern&nbsp;: public Pattern<br>
{<br>
&nbsp;&nbsp;&nbsp; public:</code><br>
<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // constructor<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyPattern (const int32_t width, const int32_t height);</code><br>
<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // destructor<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~MyPattern (void);</code><br>
<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // reset to first frame in animation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void init (void);</code><br>
<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // calculate next frame in the animation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool next (void);</code><br>
<br>
<code>&nbsp;&nbsp;&nbsp; private:</code><br>
<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // any private control, configuration, state variables, etc.<br>
};</code><br>
<br>
</p>
<code>#endif</code></div>
<p><span style="font-size:12px"><strong>Listing 1. Example pattern subclass C++ header file.</strong></span></p>
<div style="background: rgb(238, 238, 238) none repeat scroll 0% 0%; border: 1px solid rgb(204, 204, 204); padding: 5px 10px; --darkreader-inline-bgcolor:#222426; --darkreader-inline-bgimage:none; --darkreader-inline-border-top:#3e4446; --darkreader-inline-border-right:#3e4446; --darkreader-inline-border-bottom:#3e4446; --darkreader-inline-border-left:#3e4446;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""><code>#include &lt;stdio.h&gt;<br>
</code><p><code>#include &lt;stdlib.h&gt;<br>
#include &lt;stdint.h&gt;</code><br>
<br>
<code>#include "globals.h"<br>
#include "pattern.h"<br>
#include "mypattern.h"</code><br>
<br>
<code>//---------------------------------------------------------------------------------------------<br>
// constructors<br>
//</code><br>
<br>
<code>MyPattern::MyPattern (const int32_t width, const int32_t height)&nbsp;: Pattern (width, height)<br>
{<br>
}</code><br>
<br>
<code>//---------------------------------------------------------------------------------------------<br>
// destructor<br>
//</code><br>
<br>
<code>MyPattern::~MyPattern (void)<br>
{<br>
}</code><br>
<br>
<code>//---------------------------------------------------------------------------------------------<br>
// init -- reset to first frame in animation<br>
//</code><br>
<br>
<code>void MyPattern::init (void)<br>
{<br>
&nbsp;&nbsp;&nbsp; // code to reset to first frame in animation<br>
}</code><br>
<br>
<code>//---------------------------------------------------------------------------------------------<br>
// next -- calculate next frame in animation<br>
//</code><br>
<code>bool MyPattern::next (void)<br>
{<br>
&nbsp;&nbsp;&nbsp; // code to generate next frame in animation<br>
</code></p><code>
}</code></div>
<p><span style="font-size:12px"><strong>Listing 2. Example pattern subclass C++ source file.</strong></span></p>
<p>Becase the <em>init</em> and <em>next</em> methods are defined as pure virtual functions in the parent <em>Pattern</em> class, your new subclass must define the <em>init</em> and <em>next</em> methods.</p>
<p>The <em>init</em> method must contain code to reset the animation to 
the first frame of the animation. If you were creating a Pattern 
subclass to display an animated GIF on the LED panel, your <em>init </em>method,
 might open the GIF file, parse the frames in the file, store those 
frames in local memory, set the frame pointer to the first frame of the 
GIF, and set the frame delay timer to 0. The <em>init</em> method should not modify <em>gLevels </em>or call <em>WriteLevels.</em></p>
<p>The <em>next</em> method must contain code to generate a frame of the animation, store the created frame in <em>gLevels</em>,
 and advance to the next frame of the animation. In our example subclass
 to display an animated GIF, when the frame delay timer expires, we’d 
copy the frame of the animation pointed to by the frame pointer to the <em>gLevels</em>
 buffer, advance the frame pointer to the next frame, and set the frame 
delay timer to the delay between frames of the GIF animation. If the 
timer had not expired, we’d decrement the timer and return without doing
 anything else.</p>
<p>The <em>next </em>method returns a boolean value to indicate when a 
convenient stopping point in the animation has been reached. In the GIF 
example, the next method might usually return false but would return 
true after the last frame of the animated GIF has been displayed for the
 amount of time indicated by the frame delay timer. This boolean value 
indicates to the calling function that now would be a good time to 
either increment a count of how many times the animation has been 
displayed or that it is a good time to switch to displaying a different 
pattern or animation. The <em>next</em> method should not call <em>WriteLevels;</em> only the caller of <em>next</em> should call <em>WriteLevels.</em></p>
<p>After coding your new pattern subclass, you’ll need to add a few 
lines to the Makefile to compile the pattern subclass. You’ll also need 
to copy, modify, and compile one of the run&lt;pattern&gt;.cpp source 
code files to instantiate and run the pattern.</p>
<p>Extra credit: create a program to display mulitple patterns in a 
sequence. The patterns should change after each animation has run for 
one complete cycle. Use the the return value of the<em> next</em> method of each pattern subclass to determine when an animation sequence has completed.</p>
<h1> <span class="mw-headline" id="Ideas_for_Improvement">Ideas for Improvement</span></h1>
<p>The following are some ideas for improving the project.</p>
<ul>
	<li>Implement global dimming.</li>
	<li>Use the GPMC bus in synchronous mode.</li>
	<li>Reduce the number of clocks required to shift the column data bits 
to two clocks. This requires learning which edge of SCLK latches the 
data on R0, G0, B0, R1, G1, B1.</li>
	<li>Drive more panels. Requires running at &gt; 10MHz and optimizing the SCLK shift process down to two clocks.</li>
</ul>
<h1> <span class="mw-headline" id="References">References</span></h1>
<p>The following references were used during construction of this project.</p>
<p><a href="https://github.com/adafruit/RGB-matrix-Panel">Adafruit’s RGB LED Panel Library on GitHub</a></p>
<p><a href="http://e2e.ti.com/group/launchyourdesign/m/msp430microcontrollerprojects/447779.aspx">TI E2E RGB LED Coffee Table</a></p>
<p><a href="http://www.mrl.nyu.edu/%7Eperlin/doc/oscar.html">Ken Perlin’s Original Perline Noise Source Code</a></p>
<p><a href="https://github.com/caseman/noise">Casey Duncan’s Python Noise Library on GitHub</a></p>
<p><a href="http://webstaff.itn.liu.se/%7Estegu/TNM022-2005/perlinnoiselinks/perlin-noise-math-faq.html">Matt Zucker’s Perlin Noise Math and Seamless Tiling FAQ</a></p>
<p><a href="http://www.sunburst-design.com/papers/CummingsSNUG2008Boston_CDC.pdf">Cliff Cummings’ Paper on Clock Domain Crossing Design and Verification Techniques</a></p>
<p><a href="http://www.batsocks.co.uk/readme/art_bcm_1.htm">LED Dimming Using Binary Code Modulation</a></p>
<h1> <span class="mw-headline" id="Afterword">Afterword</span></h1>
<p>I eventually created a new version of the project to drive six 
panels. Files related to the “6up” version of the project can be found 
in the /beagle/projects/led-panel-6up directory of my github repository.
 Unlike the “v01” project in the github repository and described in this
 tutorial, the “6up” project is not 100% ready-to-run out of the box. 
For example, there’s no step-by-step guide, you’ll need to build your own bitfile, 
and you’ll need to compile the software. The new Verilog does, however, 
includes global dimming support, uses only two clocks per 6 bits of RGB 
data to shift data into the panels, and supports up to six panels daisy 
chained together.&nbsp;</p>
<p>Here are a few photos of some of the projects built using the “6up” version of the project:</p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-cube.jpg" style="height:479px; width:720px"></p>
<p><span style="font-size:12px"><strong>Figure 23. Five-sided cube built with five panels and the “6up” Verilog.</strong></span></p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-wall-front.jpg" style="height:480px; width:720px"></p>
<p><span style="font-size:12px"><strong>Figure 24. Six-panel wall front.</strong></span></p>
<p><img alt="" src="RGB%20LED%20Panel%20Driver%20Tutorial_files/rgb-led-panel-wall-rear.jpg" style="height:480px; width:720px"></p>
<p><span style="font-size:12px"><strong>Figure 25. Six-panel wall rear.</strong></span></p>
<p>Mountain bike season is once again upon us. Time to go ride!</p>

	  <!-- /bodycontent -->
	  </div>
	<!-- /content -->
	</div>
  

</div></body></html>